---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
# This block needs cache=FALSE to set fig.width and fig.height, and have those
# persist across cached builds.

source("utils.R", local = TRUE)
knitr::opts_chunk$set(fig.width=3.5, fig.height=3.5)
```


Using Colors in Plots {#CHAPTER-COLORS}
=====================

In ggplot2's implementation of the grammar of graphics, color is an aesthetic, just like *x* position, *y* position, and size. If color is just another aesthetic, why does it deserve its own chapter? The reason is that color is a more complicated aesthetic than the others. Instead of simply moving geoms left and right or making them larger and smaller, when you use color, there are many degrees of freedom and many more choices to make. What palette should you use for discrete values? Should you use a gradient with several different hues? How do you choose colors that can be interpreted accurately by those with color-vision deficiencies? In this chapter, I'll address these issues.


Setting the Colors of Objects {#RECIPE-COLORS-SETTING}
-----------------------------

### Problem

You want to set the color of some geoms in your graph.

### Solution

In the call to the geom, set the values of `colour` or `fill` (Figure \@ref(fig:FIG-COLORS-SETTING)):

```{r FIG-COLORS-SETTING, fig.show="hold", fig.cap="Left: setting fill and colour; right: setting colour for points", message=FALSE}
library(MASS) # For the data set
ggplot(birthwt, aes(x = bwt)) + geom_histogram(fill = "red", colour = "black")

ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point(colour = "red")
```

### Discussion

In ggplot2, there's an important difference between *setting* and *mapping* aesthetic properties. In the preceding example, we set the color of the objects to "red".

Generally speaking, colour controls the color of lines and of the outlines of polygons, while fill controls the color of the fill area of polygons. However, point shapes are sometimes a little different. For most point shapes, the color of the entire point is controlled by colour, not fill. The exception is the point shapes (21–25) that have both a fill and an outline.

### See Also

For more information about point shapes, see Recipe \@ref(RECIPE-LINE-GRAPH-POINT-APPEARANCE).

See Recipe \@ref(RECIPE-COLORS-PALETTE-DISCRETE-MANUAL) for more on specifying colors.


Representing Variables with Colors {#RECIPE-COLORS-MAPPING}
---------------------------

### Problem

You want to use a variable (column from a data frame) to control the color of geoms.

### Solution

In the call to the geom, inside of `aes()`, set the value of `colour` or `fill` to the name of one of the columns in the data (Figure \@ref(fig:FIG-COLORS-MAPPING)):

```{r eval=FALSE}
library(gcookbook) # For the data set

# These both have the same effect
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_bar(colour = "black", position = "dodge")

ggplot(cabbage_exp, aes(x = Date, y = Weight)) +
    geom_bar(aes(fill = Cultivar), colour = "black", position = "dodge")

# These both have the same effect
ggplot(mtcars, aes(x = wt, y = mpg, colour = cyl)) + geom_point()

ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point(aes(colour = cyl))
```

```{r FIG-COLORS-MAPPING, echo=FALSE, fig.show="hold", fig.cap="Left: mapping a variable to fill; right: mapping a variable to colour for points"}
library(gcookbook) # For the data set

ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_bar(colour = "black", position = "dodge", stat = "identity")

ggplot(mtcars, aes(x = wt, y = mpg, colour = cyl)) + geom_point()
```

When the mapping is specified in `ggplot()` it is used as the default mapping, which is inherited by all the geoms. Within a geom, the default mappings can be overridden.

### Discussion

In the `cabbage_exp` example, the variable `Cultivar` is mapped to `fill`. The `Cultivar` column in `cabbage_exp` is a factor, so ggplot treats it as a categorical variable. You can check the type using `str()`:

```{r}
str(cabbage_exp)
```

In the `mtcars` example, `cyl` is numeric, so it is treated as a continuous variable. Because of this, even though the actual values of `cyl` include only 4, 6, and 8, the legend has entries for the intermediate values 5 and 7. To make ggplot treat `cyl` as a categorical variable, you can convert it to a factor in the call to `ggplot()`, or you can modify the data so that the column is a character vector or factor (Figure \@ref(fig:FIG-COLORS-MAPPING-FACTOR)):

```{r FIG-COLORS-MAPPING-FACTOR, echo=FALSE, fig.show="hold", fig.cap="Mapping to colour with a continuous variable converted to a factor"}
# Convert to factor in call to ggplot()
ggplot(mtcars, aes(x = wt, y = mpg, colour = factor(cyl))) + geom_point()

# Another method: Convert to factor in the data
m <- mtcars              # Make a copy of mtcars
m$cyl <- factor(m$cyl)   # Convert cyl to a factor
ggplot(m, aes(x = wt, y = mpg, colour = cyl)) + geom_point()
```

### See Also

You may also want to change the colors that are used in the scale. For continuous data, see Recipe \@ref(RECIPE-COLORS-PALETTE-CONTINUOUS). For discrete data, see Recipe \@ref(RECIPE-COLORS-PALETTE-DISCRETE) and Recipe \@ref(RECIPE-COLORS-PALETTE-DISCRETE-MANUAL).


Using a Different Palette for a Discrete Variable {#RECIPE-COLORS-PALETTE-DISCRETE}
-------------------------------------------------

### Problem

You want to use different colors for a discrete mapped variable.

### Solution

Use one of the scales listed in Table \@ref(tab:TABLE-DISCRETE-FILL-AND-COLOR-SCALES).

Table: (\#tab:TABLE-DISCRETE-FILL-AND-COLOR-SCALES) Discrete fill and color scales

+-------------------------+---------------------------+-----------------------+
| Fill scale              | Color scale               | Description           |
+=========================+===========================+=======================+
| `scale_fill_discrete()` | `scale_colour_discrete()` | Colors evenly spaced  |
|                         |                           | around the color      |
|                         |                           | wheel (same as `hue`) |
+-------------------------+---------------------------+-----------------------+
| `scale_fill_hue()`      | `scale_colour_hue()`      | Colors evenly spaced  |
|                         |                           | around the color      |
|                         |                           | wheel (same as        |
|                         |                           | `discrete`)           |
+-------------------------+---------------------------+-----------------------+
| `scale_fill_grey()`     | `scale_colour_grey()`     | Greyscale palette     |
+-------------------------+---------------------------+-----------------------+
| `scale_fill_brewer()`   | `scale_colour_brewer()`   | ColorBrewer palettes  |
+-------------------------+---------------------------+-----------------------+
| `scale_fill_manual()`   | `scale_colour_manual()`   | Manually specified    |
|                         |                           | colors                |
+-------------------------+---------------------------+-----------------------+


In the example here we'll use the default palette (hue), and a ColorBrewer palette (Figure \@ref(fig:FIG-COLORS-PALETTE-DISCRETE)):

```{r FIG-COLORS-PALETTE-DISCRETE, fig.show="hold", fig.cap="Left: default palette (using hue); right: a ColorBrewer palette", fig.width=4.5}
library(gcookbook) # For the data set

# Base plot
p <- ggplot(uspopage, aes(x = Year, y = Thousands, fill = AgeGroup)) + geom_area()

# These three all have the same effect
p
# p + scale_fill_discrete()
# p + scale_fill_hue()

# ColorBrewer palette
p + scale_fill_brewer()
```

### Discussion

Changing a palette is a modification of the color (or fill) scale: it involves a change in the mapping from numeric or categorical values to aesthetic attributes. There are two types of scales that use colors: *fill* scales and *color* scales.

With `scale_fill_hue()`, the colors are taken from around the color wheel in the HCL (hue-chroma-lightness) color space. The default lightness value is 65 on a scale from 0–100. This is good for filled areas, but it's a bit light for points and lines. To make the colors darker for points and lines, as in Figure \@ref(fig:FIG-COLORS-PALETTE-LIGHTNESS) (right), set the value of `l` (luminance/lightness):

```{r FIG-COLORS-PALETTE-LIGHTNESS, fig.show="hold", fig.cap="Left: points with default lightness; right: with lightness set to 45", fig.width=4.5}
# Basic scatter plot
h <- ggplot(heightweight, aes(x = ageYear, y = heightIn, colour = sex)) +
    geom_point()

# Default lightness = 65
h

# Slightly darker
h + scale_colour_hue(l = 45)
```


The ColorBrewer package provides a number of palettes. You can generate a graphic showing all of them, as shown in Figure \@ref(fig:FIG-COLORS-PALETTE-BREWER):

```{r FIG-COLORS-PALETTE-BREWER, fig.cap="All the ColorBrewer palettes", fig.height=8, fig.width=8}
library(RColorBrewer)
display.brewer.all()
```

The ColorBrewer palettes can be selected by name. For example, this will use the Oranges palette (Figure \@ref(fig:FIG-COLORS-PALETTE-BREWER-NAME)):

```{r FIG-COLORS-PALETTE-BREWER-NAME, fig.cap="Using a named ColorBrewer palette", fig.width=4.5}
p + scale_fill_brewer(palette = "Oranges")
```

You can also use a palette of greys. This is useful for print when the
output is in black and white. The default is to start at 0.2 and end at 0.8, on a scale from 0 (black) to 1 (white), but you can change the range, as shown in Figure \@ref(fig:FIG-COLORS-PALETTE-GREY).

```{r FIG-COLORS-PALETTE-GREY, fig.show="hold", fig.cap="Left: using the default grey palette; right: a different grey palette", fig.width=4.5}
p + scale_fill_grey()

# Reverse the direction and use a different range of greys
p + scale_fill_grey(start = 0.7, end = 0)
```

### See Also

See Recipe \@ref(RECIPE-LEGEND-REVERSE) for more information about reversing the legend.

To select colors manually, see Recipe \@ref(RECIPE-COLORS-PALETTE-DISCRETE-MANUAL).

For more about ColorBrewer, see <http://colorbrewer2.org>.


Using a Manually Defined Palette for a Discrete Variable {#RECIPE-COLORS-PALETTE-DISCRETE-MANUAL}
--------------------------------------------------------

### Problem

You want to use different colors for a discrete mapped variable.

### Solution

In the example here, we'll manually define colors by specifying values with `scale_colour_manual()` (Figure \@ref(fig:FIG-COLORS-PALETTE-DISCRETE-MANUAL)). The colors can be named, or they can be specified with RGB values:

```{r FIG-COLORS-PALETTE-DISCRETE-MANUAL, fig.show="hold", fig.cap="Left: scatter plot with named colors; right: with slightly different RGB colors", fig.width=4}
library(gcookbook) # For the data set

# Base plot
h <- ggplot(heightweight, aes(x = ageYear, y = heightIn, colour = sex)) + geom_point()

# Using color names
h + scale_colour_manual(values = c("red", "blue"))

# Using RGB values
h + scale_colour_manual(values = c("#CC6666", "#7777DD"))
```

For fill scales, use `scale_fill_manual()` instead.

### Discussion

The order of the items in the values vector matches the order of the factor levels for the discrete scale. In the preceding example, the order of sex is f, then m, so the first item in values goes with f and the second goes with m. Here's how to see the order of factor levels:

```{r}
levels(heightweight$sex)
```

If the variable is a character vector, not a factor, it will automatically be converted to a factor, and by default the levels will appear in alphabetical order.

It's possible to specify the colors in a different order by using a named vector:

```{r eval=FALSE}
h + scale_colour_manual(values = c(m = "blue", f = "red"))
```

There is a large set of named colors in R, which you can see by running `color()`. Some basic color names are useful: "white", "black", "grey80", "red", "blue", "darkred", and so on. There are many other named colors, but their names are generally not very informative (I certainly have no idea what "thistle3" and "seashell" look like), so it's often easier to use numeric RGB values for specifying colors.

RGB colors are specified as six-digit hexadecimal (base-16) numbers of the form `#RRGGBB`. In hexadecimal, the digits go from 0 to 9, and then continue with A (10 in base 10) to F (15 in base 10). Each color is represented by two digits and can range from 00 to FF (255 in base 10). So, for example, the color `#FF0099` has a value of 255 for red, 0 for green, and 153 for blue, resulting in a shade of magenta. The hexadecimal numbers for each color channel often repeat the same digit because it makes them a little easier to read, and because the precise value of the second digit has a relatively insignificant effect on appearance.

Here are some rules of thumb for specifying and adjusting RGB colors:

* In general, higher numbers are brighter and lower numbers are darker.
* To get a shade of grey, set all the channels to the same value.
* The opposites of RGB are CMY: Cyan, Magenta, and Yellow. Higher values for the red channel make it more red, and lower values make it more cyan. The same is true for the pairs green and magenta, and blue and yellow.

### See Also

A [chart of RGB color codes](http://html-color-codes.com).

 
Using a Colorblind-Friendly Palette {#RECIPE-COLORS-PALETTE-DISCRETE-COLORBLIND}
-----------------------------------

### Problem

You want to use colors that can be distinguished by colorblind viewers.

### Solution

Use the palette defined here (`cb_palette`) with `scale_fill_manual()` (Figure \@ref(fig:FIG-COLORS-PALETTE-DISCRETE-COLORBLIND)):

```{r FIG-COLORS-PALETTE-DISCRETE-COLORBLIND, fig.show="hold", fig.cap="A plot with the colorblind-friendly palette", fig.width=4.5}
library(gcookbook) # For the data set

# Base plot
p <- ggplot(uspopage, aes(x = Year, y = Thousands, fill = AgeGroup)) + geom_area()

# The palette with grey:
cb_palette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
                "#0072B2", "#D55E00", "#CC79A7")

# Add it to the plot
p + scale_fill_manual(values = cb_palette)
```

A chart of the colors is shown in Figure \@ref(fig:FIG-COLORS-PALETTE-DISCRETE-COLORBLIND-CHART).

```{r FIG-COLORS-PALETTE-DISCRETE-COLORBLIND-CHART, echo=FALSE, fig.cap="Colorblind palette with RGB values"}
knitr::include_graphics("fig/colorblind_palette.png")
```
In some cases it may be better to use black instead of grey. To do this, replace the `#999999` with `#000000` or `"black"`:

```{r}
c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00",
  "#CC79A7")
```

### Discussion

About 8 percent of males and 0.5 percent of females have some form of color-vision deficiency, so there's a good chance that someone in your audience will be among them.

There are many different forms of color blindness. The palette here is designed to enable people with any of the most common forms of color-vision deficiency to distinguish the colors. (Monochromacy, or total colorblindness, is rare. Those who have it can only see differences in brightness.)

### See Also

The [source of this palette](http://jfly.iam.u-tokyo.ac.jp/color/).

The [Color Oracle program](http://colororacle.org) can simulate how things on your screen appear to someone with color vision deficiency, but keep in mind that the simulation isn't perfect. In my informal testing, I viewed an image with simulated red-green deficiency, and I could distinguish the colors just fine--but others with actual red-green deficiency viewed the same image and couldn't tell the colors apart!


Using a Manually Defined Palette for a Continuous Variable {#RECIPE-COLORS-PALETTE-CONTINUOUS}
----------------------------------------------------------

### Problem

You want to use different colors for a continuous variable.

### Solution

In the example here, we'll specify the colors for a continuous variable using various gradient scales (Figure \@ref(fig:FIG-COLORS-PALETTE-CONTINUOUS)). The colors can be named, or they can be specified with RGB values:

```{r FIG-COLORS-PALETTE-CONTINUOUS, fig.show="hold", fig.cap="Clockwise from top left: default colors, two-color gradient with `scale_colour_gradient()`, three-color gradient with midpoint with `scale_colour_gradient2()`, four-color gradient with `scale_colour_gradientn()`", fig.width=4}
library(gcookbook) # For the data set

# Base plot
p <- ggplot(heightweight, aes(x = ageYear, y = heightIn, colour = weightLb)) +
     geom_point(size = 3)

p

# With a gradient between two colors
p + scale_colour_gradient(low = "black", high = "white")

# A gradient of n colors
p + scale_colour_gradientn(colours = c("darkred", "orange", "yellow", "white"))

# A gradient with a white midpoint
library(scales)
p + scale_colour_gradient2(low = muted("red"), mid = "white", high = muted("blue"),
    midpoint = 110)
```


For fill scales, use `scale_fill_xxx()` versions instead, where `xxx` is one of `gradient`, `gradient2`, or `gradientn`.

### Discussion

Mapping continuous values to a color scale requires a continuously changing palette of colors. Table \@ref(tab:TABLE-CONTINUOUS-COLOR-SCALES). lists the continuous color and fill scales.

Table: (\#tab:TABLE-CONTINUOUS-COLOR-SCALES) Continuous fill and color scales

+--------------------------+----------------------------+-----------------------+
| Fill scale               | Color scale                | Description           |
+==========================+============================+=======================+
| `scale_fill_gradient()`  | `scale_colour_gradient()`  | Two-color gradient    |
+--------------------------+----------------------------+-----------------------+
| `scale_fill_gradient2()` | `scale_colour_gradient2()` | Gradient with a       |
|                          |                            | middle color and two  |
|                          |                            | colors that diverge   |
|                          |                            | from it               |
+--------------------------+----------------------------+-----------------------+
| `scale_fill_gradientn()` | `scale_colour_gradientn()` | Gradient with *n*     |
|                          |                            | colors, equally       |
|                          |                            | spaced                |
+--------------------------+----------------------------+-----------------------+
 
Notice that we used the `muted()` function in the examples. This is a function from the scales package that returns an RGB value that is a less-saturated version of the color chosen.

### See Also

If you want use a discrete (categorical) scale instead of a continuous one, you can recode your data into categorical values. See Recipe \@ref(RECIPE-DATAPREP-RECODE-CONTINUOUS).


Coloring a Shaded Region Based on Value {#RECIPE-COLORS-AREA-VALUE}
---------------------------------------

### Problem

You want to set the color of a shaded region based on the *y* value.

### Solution

Add a column that categorizes the *y* values, then map that column to fill. In this example, we’ll first categorize the values as positive or negative:

```{r}
library(gcookbook) # For the data set
cb <- subset(climate, Source=="Berkeley")
cb$valence[cb$Anomaly10y >= 0] <- "pos"
cb$valence[cb$Anomaly10y < 0]  <- "neg"
cb
```

Once we've categorized the values as positive or negative, we can make the plot, mapping valence to the fill color, as shown in Figure \@ref(fig:FIG-COLORS-AREA-VALUE):

```{r FIG-COLORS-AREA-VALUE, fig.cap="Mapping valence to fill color-notice the red area under the zero line around 1950", fig.width=10}
ggplot(cb, aes(x = Year, y = Anomaly10y)) +
    geom_area(aes(fill = valence)) +
    geom_line() +
    geom_hline(yintercept = 0)
```

### Discussion

If you look closely at the figure, you'll notice that there are some stray shaded areas near the zero line. This is because each of the two colored areas is a single polygon bounded by the data points, and the data points are not actually at zero. To solve this problem, we can interpolate the data to 1,000 points by using `approx()`:

```{r}
# approx() returns a list with x and y vectors
interp <- approx(cb$Year, cb$Anomaly10y, n = 1000)

# Put in a data frame and recalculate valence
cbi <- data.frame(Year = interp$x, Anomaly10y = interp$y)
cbi$valence[cbi$Anomaly10y >= 0] <- "pos"
cbi$valence[cbi$Anomaly10y < 0]  <- "neg"
```

It would be more precise (and more complicated) to interpolate exactly where the line crosses zero, but `approx()` works fine for the purposes here.

Now we can plot the interpolated data (Figure \@ref(fig:FIG-COLORS-AREA-VALUE-INTERPOLATED)). This time we'll make a few adjustments -- we'll make the shaded regions partially transparent, change the colors, remove the legend, and remove the padding on the left and right sides:

```{r FIG-COLORS-AREA-VALUE-INTERPOLATED, fig.cap="Shaded regions with interpolated data", fig.width=10}
ggplot(cbi, aes(x = Year, y = Anomaly10y)) +
    geom_area(aes(fill = valence), alpha = .4) +
    geom_line() +
    geom_hline(yintercept = 0) +
    scale_fill_manual(values = c("#CCEEFF", "#FFDDDD"), guide = FALSE) +
    scale_x_continuous(expand = c(0, 0))
```
