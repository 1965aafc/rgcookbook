---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
source("utils.R", local = TRUE)
```

ggplot2 and plotting basics {#CHAPTER-GGPLOT2-BASICS}
========

Most of the recipes in this book involve the ggplot2 package, which has quickly become one of the main packages used in the R community for plots and graphics. 

Since ggplot2 was first created (and subsequently updated) by Hadley Wickham, the package has attracted many users in the R community because of its versatility, clear and consistent interface, and beautiful output. The name ggplot2 comes from from Leland Wilkinson's *grammar of graphics*, which provides a formal, structured perspective on how to describe data graphics, and serves as the conceptual foundation for the design of ggplot2.

There are a number of other graphing packages that exist that can do some things that ggplot2 can't do, or do better than ggplot2. There are other things that ggplot2 can do, but that specialized packages are better suited to handling. I've listed some of these other packages in \@ref(#CHAPTER-GGPLOT2). For most purposes, though, I believe that ggplot2 gives the best return on time invested, and it provides beautiful, publication-ready results.

This chapter provides a brief introduction to using ggplot2, so that you'll have a better understanding of how ggplot2 plots are constructed, and how the syntax works. This is just the surface though. If you're interested in a deeper understanding of ggplot2, I encourage you to read the materials in \@ref(CHAPTER-GGPLOT2)! 

All of the examples in this book will require that you load ggplot2. You can do this by loading the ggplot2 package directly, or by loading the tidyverse package, which includes ggplot2.

```{r}
library(ggplot2)

# or you can load the tidyverse package with the command `library(tidyverse)`
```


Understanding the basic ggplot2 syntax
--------------------

### Problem

You want to build a plot using ggplot2.

### Solution

Determine the variables you want to plot, and use ggplot2 syntax to construct a plot. 

In the example below, we are trying to plot data from the `mpg` dataset, which contains information about the fuel economy of different types of vehicles. In particular, we will be plotting the variable `hwy`, the highway miles per gallon, for different types of vehicles, which is denoted by the variable `class`.

> **Note**
>
> You can find out more about this dataset by typing in `?mpg`.  

There are different ways that we could plot this data. For example, two ways we could represent this data is by using a bar plot (Figure \@ref(fig:FIG-GGPLOT2-BASE), left), or a box plot (Figure \@ref(fig:FIG-GGPLOT2-BASE), right). 

```{r FIG-GGPLOT2-BASE, small.mar=TRUE, fig.show="hold", fig.cap="Representing the data using a bar plot (left); Using boxplots (right)"}
ggplot(mpg, aes(x = class, y = hwy)) + 
  geom_col()

ggplot(mpg, aes(x = class, y = hwy)) + 
  geom_boxplot() 
```

### Discussion

There is a specific logic and syntax to building ggplot2 plots. The first thing that you want to do is to think through the kind of data that you have. 

The `summary()` function provides basic descriptive statistics (the minimum, maximum, median, mean, and first & third quartile values) for numeric variables, and tells you the number of values corresponding to each character value or factor level if it is a character or factor variable. Let's look at the basics of the two variables we want to plot, `class` and `hwy`:

```{r}
mpg %>% 
  select(class, hwy) %>% 
  summary()
```

From the output above we can see that `class` is a discrete, character variable, whereas `hwy` is a numeric, continous variable.

With this knowledge in hand, we can start to build our plot. For any given type of variable there are a number of different plots you could use to visualize the data. One of the advantages of ggplot2 is that it makes it easy to switch between these different plots so that you can quickly experiment with different kinds of visualization, in order to find the visual that will best illustrate the point you want to make with the data. 

There is a specific syntax to building a ggplot. As you go through this book you'll quickly notice that each ggplot typically starts with a line that looks like this:

```{r, eval=FALSE}
ggplot(mpg, aes(x = class, y = hwy))
```

This first line has several purposes. The first purpose is to signal to R that we are starting to build a ggplot - any subsequent addition to this first line is indicated with a `+` (plus) sign. 

Secondly, this first line indicates the dataset that the data for the plot comes from. The dataset is always the first input into the line - in this case, our dataset is called `pressure`.

Third, this line indicates what variables should be used in the plot, and how. This information is contained within `aes()`, which stands for the "aesthetic" parameters of the plot. In this case we have specified that we want to map `temperature` on the x axis, and `pressure` on the y axis.

Look at what happens when we run just the first line:

```{r FIG-GGPLOT2-BASE, small.mar=TRUE, fig.show="hold", fig.cap="Base ggplot area generated by the first line"}
ggplot(mpg, aes(x = class, y = hwy))
```

What we can see in (Figure \@ref(fig:FIG-GGPLOT2-BASE)) is that running the first line generates the base plot backgruond for our data visualization. This base plot is configured according to the initial parameters we specified: the x-axis is labeled with `class` and lists the different types of vehicles within `class`, while the y-axis is labeled `hwy` and has a numeric axis scale. Note that the scale for the y-axis corresponds to the range of `hwy`:

```{r}
range(mpg$hwy)
```

Now that we have the base plot, we can specify how we actually want to plot the data. For example, let's represent our data as points that we will add onto our base plot (\@ref(fig:FIG-GGPLOT2-BASE-BAR)):

```{r FIG-GGPLOT2-BASE-BAR, small.mar=TRUE, fig.show="hold", fig.cap="Adding our data in the form of bars to the base ggplot area"}
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_col()
```

As mentioned above, there are many different ways of representing the same data. Figure \@ref(fig:FIG-GGPLOT2-BASE) shows this data plotted as a bar plot, or as a boxplot. We can also try to represent our data using dots instead (\@ref(fig:FIG-GGPLOT2-BASE-DOT)). For this combination of a discrete x variable and a continous y variable, one option is to use a dotplot. Note that these different plots all share the first same line, and only requre a change to the second line of code:

```{r, eval=FALSE}
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_bar()

ggplot(mpg, aes(x = class, y = hwy)) +
  geom_boxplot()

ggplot(mpg, aes(x = class, y = hwy)) +
  geom_dotplot()
```

```{r FIG-GGPLOT2-BASE-DOT, echo=FALSE, small.mar=TRUE, fig.show="hold", fig.cap="Representing our data as a dotplot instead"}
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_dotplot()
```

ggplot works by sequentially adding layers on top of the base plot. For example, the following plots demonstrates how ggplots are created in layers. The plot on the left of Figure \@ref(fig:FIG-GGPLOT2-BASE-COMBINED) shows a violin plot with a dotplot added on top, whereas the plot on the right shows a dotplot with a violin plot added on top:

```{r FIG-GGPLOT2-BASE-COMBINED, small.mar=TRUE, fig.show="hold", fig.cap="A violin plot was drawn first, to which a dotplot was added (left); the reverse (right)"}
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_violin() +
  geom_dotplot()

ggplot(mpg, aes(x = class, y = hwy)) +
  geom_dotplot() +
  geom_violin()
```

Beyond adding the data itself, the `+` ggplot operator can be used to add other layers and modifications to the plot (e.g. Figure \@ref(fig:FIG-GGPLOT2-BASE-THEME)). The best practice for making your code readable (for others, and your future self!) is to make sure that each layer (each line that ends with `+`) is a new line of code. Following this code style will make it easy to quickly see what layers make up your plot, to make changes to specific layers, or to quickly switch the order of layers.

The rest of this book goes through many of these options. One of the strengths of ggplot2 is that while it is incredibly customizable, the syntax and the process of adding layers to your plot remains consistent across the different types of modifications you can make. 

```{r FIG-GGPLOT2-BASE-THEME, small.mar=TRUE, fig.show="hold", fig.cap="Default bar plot (left); Adding a layer of modification that changes the theme of the plot (right)"}
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_bar()

ggplot(mpg, aes(x = class, y = hwy)) +
  geom_bar() +
  theme_bw()
```

Finally, keep in mind that there are always better and worse ways to represent your data. The plot types chosen in Figure \@ref(fig:FIG-GGPLOT2-BASE-COMBINED) don't necessarily make a clear point with the data - if anything, they make the data more confusing. Being able to experiment easily with different plot types is great for quickly testing different visualizations, but make sure that you're ultimately picking the visualization that best serves the message that you want your data to get across.

### See Also

You can consult the ggplot2 cheatsheet oneline for more ideas on how to plot your data: <https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf>.

For more on recommended code style: <http://style.tidyverse.org/>.


Quickly Exploring Data {#CHAPTER-QUICK}
======================

Although I've used the ggplot2 package for most of the graphics in this book, it is not the only way to plot data. For very quick exploration of data, it's sometimes useful to use the plotting functions in base R. These are installed by default with R and do not require any additional packages to be installed. They're quick to type, straightforward to use in simple cases, and run very quickly.

If you want to do anything beyond very simple plots, though, it's generally better to switch to ggplot2. This is in part because ggplot2 provides a unified interface and set of options, instead of the grab bag of modifiers and special cases required in base graphics. Once you learn how ggplot2 works, you can use that knowledge for everything from scatter plots and histograms to violin plots and maps.

Each recipe in this section shows how to make a graph with base graphics. Each recipe also shows how to make a similar graph with the `ggplot()` function in ggplot2. The previous edition of this book also gave examples using the `qplot()` function from the ggplot2 package, but now it is recommended to just use `ggplot()` instead.

If you already know how to use R's base graphics, having these examples side by side will help you transition to using ggplot2 for when you want to make more sophisticated graphics.

Creating a Scatter Plot {#RECIPE-QUICK-SCATTER}
-----------------------

### Problem

You want to create a scatter plot.

### Solution

To make a scatter plot (Figure \@ref(fig:FIG-QUICK-SCATTER-BASE)), use `plot()` and pass it a vector of *x* values followed by a vector of *y* values:

```{r FIG-QUICK-SCATTER-BASE, small.mar=TRUE, fig.cap='Scatter plot with base graphics', out.width="70%"}
plot(mtcars$wt, mtcars$mpg)
```

The `mtcars$wt` returns the column named `wt` from the `mtcars` data frame, and `mtcars$mpg` is the `mpg` column.

With ggplot2, you can get a similar result using the `ggplot()` function (Figure Figure \@ref(fig:FIG-QUICK-SCATTER-GGPLOT)):

```{r FIG-QUICK-SCATTER-GGPLOT, fig.cap='Scatter plot with ggplot2', out.width="70%"}
library(ggplot2)

ggplot(mtcars, aes(x = wt, y = mpg)) + 
  geom_point()
```

The first part, `ggplot()`, tell is to create a plot object, and the second part, `geom_point()`, tells it to add a layer of points to the plot.

The usual way to use `ggplot()` is to pass it a data frame (`mtcars`) and then tell it which columns to use for the x and y values. If you want to pass it two vectors for x and y values, you can use `data = NULL`, and then pass it the vectors. Keep in mind that ggplot2 is designed to work with data frames as the data source, not individual vectors, and that using it this way will only allow you to use a limited part of its capabilities.

```{r, eval=FALSE}
ggplot(data = NULL, aes(x = mtcars$wt, y = mtcars$mpg)) + 
  geom_point()
```

It is common to see `ggplot()` commands spread across multiple lines, so you may see the above code also written like this:

### See Also

See Chapter \@ref(CHAPTER-SCATTER) for more in-depth information about creating scatter plots.


Creating a Line Graph {#RECIPE-QUICK-LINE}
---------------------

### Problem

You want to create a line graph.

### Solution

To make a line graph using `plot()` (Figure \@ref(fig:FIG-QUICK-LINE-BASE), left), pass it a vector of x values and a vector of y values, and use `type = "l"`:

```{r eval=FALSE}
plot(pressure$temperature, pressure$pressure, type = "l")
```

```{r FIG-QUICK-LINE-BASE, echo=FALSE, small.mar=TRUE, fig.show="hold", fig.cap="Line graph with base graphics (left); With points and another line (right)"}
plot(pressure$temperature, pressure$pressure, type = "l")

# This code should be the same as the following block, but there's a problem: 
# knitr won't show the output of the previous plot() if this line is exactly 
# like the one above So in this case we'll plot points and then lines. The 
# output looks the same and knitr won't suppress the output.
plot(pressure$temperature, pressure$pressure, type = "p")
lines(pressure$temperature, pressure$pressure)
lines(pressure$temperature, pressure$pressure/2, col = "red")
points(pressure$temperature, pressure$pressure/2, col = "red")
```

To add points and/or multiple lines (Figure \@ref(fig:FIG-QUICK-LINE-BASE), right), first call `plot()` for the first line, then add points with `points()` and additional lines with `lines()`:

```{r eval=FALSE}
plot(pressure$temperature, pressure$pressure, type = "l")
points(pressure$temperature, pressure$pressure)

lines(pressure$temperature, pressure$pressure/2, col = "red")
points(pressure$temperature, pressure$pressure/2, col = "red")
```

With ggplot2, you can get a similar result using `geom_line()` (Figure \@ref(fig:FIG-QUICK-LINE-GGPLOT)):

```{r eval=FALSE}
library(ggplot2)
ggplot(pressure, aes(x = temperature, y = pressure)) + 
  geom_line()
```

```{r FIG-QUICK-LINE-GGPLOT, echo=FALSE, fig.show="hold", fig.cap="Line graph with `ggplot()` (left); With points added (right)"}

ggplot(pressure, aes(x = temperature, y = pressure)) + 
  geom_line()

# Equivalent to:
ggplot(pressure, aes(x = temperature, y = pressure)) + 
  geom_line() + 
  geom_point()
```

As with scatter plots, you can pass you data in vectors instead of in a data frame (but this will limit the things you can do later with the plot):

```{r eval=FALSE}
ggplot(pressure, aes(x = temperature, y = pressure)) +
  geom_line() +
  geom_point()
```

> **Note**
>
> It's common with `ggplot()` to split the command on multiple lines, ending each line with a `+` so that R knows that the command will continue on the next line.

### See Also

See Chapter \@ref(CHAPTER-LINE-GRAPH) for more in-depth information about creating line graphs.


Creating a Bar Graph {#RECIPE-QUICK-BAR}
--------------------

### Problem

You want to make a bar graph.

### Solution

To make a bar graph of values (Figure \@ref(fig:FIG-QUICK-BAR-BASE), left), use `barplot()` and pass it a vector of values for the height of each bar and (optionally) a vector of labels for each bar. If the vector has names for the elements, the names will automatically be used as labels:

```{r}
# First, take a look at the BOD data
BOD
```

```{r eval=FALSE}
barplot(BOD$demand, names.arg = BOD$Time)
```


```{r FIG-QUICK-BAR-BASE, echo=FALSE, small.mar=TRUE, fig.show="hold", fig.cap="Bar graph of values with base graphics (left); Bar graph of counts (right)"}
barplot(BOD$demand, names.arg = BOD$Time)

barplot(table(mtcars$cyl))
```

Sometimes "bar graph" refers to a graph where the bars represent the *count* of cases in each category. This is similar to a histogram, but with a discrete instead of continuous x-axis. To generate the count of each unique value in a vector, use the `table()` function:

````{r}
# There are 11 cases of the value 4, 7 cases of 6, and 14 cases of 8
table(mtcars$cyl)
```

Then pass the table to `barplot()` to generate the graph of counts:

```{r eval=FALSE}
# Generate a table of counts
barplot(table(mtcars$cyl))
```

With ggplot2, you can get a similar result using `geom_bar()` (Figure \@ref(fig:FIG-QUICK-BAR-GGPLOT)). To plot a bar graph of *values*, use `geom_col()`. Notice the difference in the output when the *x* variable is continuous and when it is discrete:

(ref:cap-FIG-QUICK-BAR-GGPLOT) Left: bar graph of values using `geom_col()` with a continuous x variable; right: with x variable converted to a factor (notice that there is no entry for 6)

```{r FIG-QUICK-BAR-GGPLOT, fig.show="hold", fig.cap="(ref:cap-FIG-QUICK-BAR-GGPLOT)"}
library(ggplot2)

# Bar graph of values. This uses the BOD data frame, with the
# "Time" column for x values and the "demand" column for y values.
ggplot(BOD, aes(x = Time, y = demand)) + 
  geom_col()

# Convert the x variable to a factor, so that it is treated as discrete
ggplot(BOD, aes(x = factor(Time), y = demand)) + 
  geom_col()
```

ggplot2 can also be used to plot the *count* of the number of data rows in each category (Figure \@ref(fig:FIG-QUICK-BAR-GGPLOT-COUNT)). Once again, notice the difference between a continuous x-axis and a discrete one. For some kinds of data, it may make more sense to convert the continuous x variable to a discrete one, with the `factor()` function.

(ref:cap-FIG-QUICK-BAR-GGPLOT-COUNT) Left: bar graph of counts using `geom_bar()` with a continuous x variable; right: with x variable converted to a factor

```{r FIG-QUICK-BAR-GGPLOT-COUNT, fig.show="hold", fig.cap="(ref:cap-FIG-QUICK-BAR-GGPLOT-COUNT)"}
# Bar graph of counts This uses the mtcars data frame, with the "cyl" column for
# x position. The y position is calculated by counting the number of rows for
# each value of cyl.
ggplot(mtcars, aes(x = cyl)) + 
  geom_bar()

# Bar graph of counts
ggplot(mtcars, aes(x = factor(cyl))) + 
  geom_bar()
```

> **Note**
>
> In previous versions of ggplot2, the recommended way to create a bar graph of values was to use `geom_bar(stat = "identity")`. As of ggplot2 2.2.0, there is a `geom_col()` function which does the same thing.

### See Also

See Chapter \@ref(CHAPTER-BAR-GRAPH) for more in-depth information about creating bar graphs.


Creating a Histogram {#RECIPE-QUICK-HISTOGRAM}
--------------------

### Problem

You want to view the distribution of one-dimensional data with a histogram.

### Solution

To make a histogram (Figure \@ref(fig:FIG-QUICK-HIST-BASE)), use `hist()` and pass it a vector of values:

```{r FIG-QUICK-HIST-BASE, small.mar=TRUE, fig.show="hold", fig.cap="Histogram with base graphics (left); With more bins. Notice that because the bins are narrower, there are fewer items in each bin. (right)"}
hist(mtcars$mpg)

# Specify approximate number of bins with breaks
hist(mtcars$mpg, breaks = 10)
```

With the ggplot2, you can get a similar result using `geom_histogram()` (Figure \@ref(fig:FIG-QUICK-HIST-GGPLOT)):

```{r FIG-QUICK-HIST-GGPLOT, fig.show="hold", fig.cap="ggplot2 histogram with default bin width (left); With wider bins (right)"}
library(ggplot2)
ggplot(mtcars, aes(x = mpg)) + 
  geom_histogram()

# With wider bins
ggplot(mtcars, aes(x = mpg)) + 
  geom_histogram(binwidth = 4)
```

When you create a histogram without specifying the bin width, `ggplot()` prints out a message telling you that it's defaulting to 30 bins, and to pick a better bin width. This is because it's important to explore your data using different bin widths; the default of 30 may or may not show you something useful about your data.

### See Also

For more in-depth information about creating histograms, see Recipes
Recipe \@ref(RECIPE-DISTRIBUTION-BASIC-HIST) and
Recipe \@ref(RECIPE-DISTRIBUTION-MULTI-HIST).


Creating a Box Plot {#RECIPE-QUICK-BOXPLOT}
-------------------

### Problem

You want to create a box plot for comparing distributions.

### Solution

To make a box plot (Figure \@ref(fig:FIG-QUICK-BOXPLOT-BASE)), use `plot()` and pass it a factor of x values and a vector of y values.  When x is a factor (as opposed to a numeric vector), it will automatically create a box plot:

```{r eval=FALSE}
plot(ToothGrowth$supp, ToothGrowth$len)
```

```{r FIG-QUICK-BOXPLOT-BASE, echo=FALSE, small.mar=TRUE, fig.show="hold", fig.cap="Box plot with base graphics (left); With multiple grouping variables (right)", fig.width=10, out.width="100%"}
layout(t(c(1,2,2)))
plot(ToothGrowth$supp, ToothGrowth$len)

boxplot(len ~ supp + dose, data = ToothGrowth)
```


If the two vectors are in the same data frame, you can also use the `boxplot()` function with formula syntax. With this syntax, you can combine two variables on the x-axis, as in Figure \@ref(fig:FIG-QUICK-BOXPLOT-BASE):

```{r eval=FALSE}
# Formula syntax
boxplot(len ~ supp, data = ToothGrowth)

# Put interaction of two variables on x-axis
boxplot(len ~ supp + dose, data = ToothGrowth)
```

With the ggplot2 package, you can get a similar result (Figure \@ref(fig:FIG-QUICK-BOXPLOT-GGPLOT)), with `geom_boxplot()`:

```{r eval=FALSE}
library(ggplot2)
ggplot(ToothGrowth, aes(x = supp, y = len)) + 
  geom_boxplot()
```


```{r FIG-QUICK-BOXPLOT-GGPLOT, echo=FALSE, fig.show="hold", fig.cap="Box plot with `ggplot()` (left); With multiple grouping variables (right)"}
ggplot(ToothGrowth, aes(supp, len)) + 
  geom_boxplot()

ggplot(ToothGrowth, aes(x = interaction(supp, dose), y = len)) + 
  geom_boxplot()
```

It's also possible to make box plots for multiple variables, by combining the variables with `interaction()`, as in Figure \@ref(fig:FIG-QUICK-BOXPLOT-GGPLOT):

```{r eval=FALSE}
ggplot(ToothGrowth, aes(x = interaction(supp, dose), y = len)) + 
  geom_boxplot()
```

> **Note**
>
> You may have noticed that the box plots from base graphics are ever-so-slightly different from those from ggplot2. This is because they use slightly different methods for calculating quantiles. See `?geom_boxplot` and `?boxplot.stats` for more information on how they differ.

### See Also

For more on making basic box plots, see Recipe \@ref(RECIPE-DISTRIBUTION-BASIC-BOXPLOT).


Plotting a Function Curve {#RECIPE-QUICK-FUNCTION}
-------------------------

### Problem

You want to plot a function curve.

### Solution

To plot a function curve, as in Figure \@ref(fig:FIG-QUICK-FUNCTION-BASE), use `curve()` and pass it an expression with the variable x:

```{r eval=FALSE}
curve(x^3 - 5*x, from = -4, to = 4)
```


```{r FIG-QUICK-FUNCTION-BASE, echo=FALSE, small.mar=TRUE, fig.show="hold", fig.cap="Function curve with base graphics (left); With user-defined function (right)"}
curve(x^3 - 5*x, from = -4, to = 4)

# Plot a user-defined function
myfun <- function(xvar) {
  1 / (1 + exp(-xvar + 10))
}
curve(myfun(x), from = 0, to = 20)
# Add a line:
curve(1 - myfun(x), add = TRUE, col = "red")
```

You can plot any function that takes a numeric vector as input and returns a numeric vector, including functions that you define yourself.  Using `add = TRUE` will add a curve to the previously created plot:

```{r eval=FALSE}
# Plot a user-defined function
myfun <- function(xvar) {
  1 / (1 + exp(-xvar + 10))
}
curve(myfun(x), from = 0, to = 20)
# Add a line:
curve(1 - myfun(x), add = TRUE, col = "red")
```

With ggplot2, you can get a similar result (Figure \@ref(fig:FIG-QUICK-FUNCTION-GGPLOT)), by using `stat_function(geom = "line")` and passing it a function that takes a numeric vector as input and returns a numeric vector:

```{r FIG-QUICK-FUNCTION-GGPLOT, fig.cap="A function curve with ggplot2", out.width="70%"}
library(ggplot2)
# This sets the x range from 0 to 20
ggplot(data.frame(x = c(0, 20)), aes(x = x)) +
  stat_function(fun = myfun, geom = "line")
```


### See Also

See Recipe \@ref(RECIPE-MISCGRAPH-FUNCTION) for more in-depth information about plotting function curves.